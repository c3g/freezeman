from django.apps import apps
import reversion
import json
import logging
from reversion.models import Version
from fms_core.models import Sample

# Parameters required for this curation
ACTION = "action"  # = rollback_extraction
CURATION_INDEX = "curation_index"  # Number indicating the order in which this action was performed during the curation.
SAMPLE_EXTRACTED_FROM_ID = "sample_extracted_from"  # The id of the sample the extraction extracted.
SAMPLES_EXTRACTED_ID = "samples_extracted"  # The ids of the samples created during the extraction from a single sample.
EXTRACTION_REVISION_ID = "extraction_revision"  # The revision that was generated by the extraction.

# Curation params template
# {CURATION_INDEX:1,ACTION:"rollback_extraction",SAMPLE_EXTRACTED_FROM_ID:51142,SAMPLES_EXTRACTED_ID:[56881,56893],EXTRACTION_REVISION_ID:621}

# Other constants
FIELD_EXTRACTED_FROM = "extracted_from_id"
SAMPLE_TYPE = 11


def rollback_extraction(params, log):
    log.info("Action [" + str(params[CURATION_INDEX]) + "] Extraction rollback started.")
    log.info("Sample extracted from : " + str(params[SAMPLE_EXTRACTED_FROM_ID]))
    log.info("Samples extracted : " + str(params[SAMPLES_EXTRACTED_ID]))
    log.info("extraction_revision : " + str(params[EXTRACTION_REVISION_ID]))
    curation_code = params[CURATION_INDEX]
    sample_model = apps.get_model("fms_core", "Sample")

    sample_extracted_from = params[SAMPLE_EXTRACTED_FROM_ID]
    error_found = False
    sample_to = []
    # Verify that each listed extracted sample has the correct source sample before proceeding.
    for index, sample_id in enumerate(params[SAMPLES_EXTRACTED_ID]):
        versions = []
        try:
            sample_to.append(sample_model.objects.get(pk=sample_id))
            versions = Version.objects.get_for_object(sample_to[index]).filter(revision_id=params[EXTRACTION_REVISION_ID])
        except sample_model.DoesNotExist:
            log.error("Sample [" + str(sample_id) + "] does not exist.")
            error_found = True
        if len(versions) > 0:
            if sample_extracted_from != versions[0].field_dict[FIELD_EXTRACTED_FROM]:
                log.error("Sample [" + str(sample_id) + "] source [" + str(versions[0].field_dict[FIELD_EXTRACTED_FROM]) + "] does not match curation parameters.")
                error_found = True
        else:
            log.error("Could not find sample [" + str(sample_id) + "] extracted during revision [" + str(params[EXTRACTION_REVISION_ID]) + "]")
            error_found = True
    # Verify that there is no undeclared extracted samples that would need to be deleted along the list from parameters.
    versions = Version.objects.filter(revision_id=params[EXTRACTION_REVISION_ID], content_type_id=SAMPLE_TYPE)\
                              .exclude(object_id__in=params[SAMPLES_EXTRACTED_ID])
    for version in versions:
        if sample_extracted_from == version.field_dict[FIELD_EXTRACTED_FROM]:
            log.error("Sample [" + str(version.object_id) + "] was extracted from sample [" + str(version.field_dict[FIELD_EXTRACTED_FROM]) + "] and is not listed in parameters.")
            error_found = True
    # Make sure the source sample exists and identify the version for the rollback.
    try:
        sample_from = sample_model.objects.get(pk=sample_extracted_from)
        versions = Version.objects.get_for_object(sample_from)
    except sample_model.DoesNotExist:
        log.error("Sample source [" + str(params[SAMPLES_EXTRACTED_ID]) + "] does not exist.")
        versions = []
        error_found = True
    version_rollback = None
    for index, version in enumerate(versions):
        if version.revision.id == params[EXTRACTION_REVISION_ID]:
            version_rollback = versions[index+1]
            # Report to the log the target extraction revision
            log.info("version index [" + str(index) + "] skipped. Version id [" + str(version.id) + "]")
            # Report to the log the index and version used for the rollback.
            log.info("version index [" + str(index+1) + "] found for revision [" + str(params[EXTRACTION_REVISION_ID]) + "]. Version id [" + str(version_rollback.id) + "]")
            break
        else:
            log.info("version index [" + str(index) + "] skipped. Version id [" + str(version.id) + "]")
    # Apply the curation action if every verifications made were successful
    if version_rollback:
        if not error_found:
            for sample in sample_to:
                id = sample.id
                sample.update_comment = "Marked for deletion"
                sample.save()
                sample.delete()
                log.info("Sample [" + str(id) + "] deleted.")
            # Rollback of sample extracted from using version preceding extraction revision
            version_rollback.revert()
            log.info("Sample [" + str(sample_extracted_from) + "] restored to version [" + str(version_rollback.id) + "].")
            curation_code = None
            log.info("Extraction rollback complete.")
        else:
            log.error("Action encountered one or more discrepancies between the requested curation and the database.")
            log.info("Extraction rollback failed.")
    else:
        log.error("Sample version to rollback to was not found.")
    return curation_code

